package dev.getelements.elements.crossfire.model;

import dev.getelements.elements.crossfire.model.error.StandardProtocolError;
import dev.getelements.elements.crossfire.model.handshake.FindHandshakeRequest;
import dev.getelements.elements.crossfire.model.handshake.JoinHandshakeRequest;
import dev.getelements.elements.crossfire.model.handshake.MatchedResponse;
import dev.getelements.elements.crossfire.model.signal.*;
import dev.getelements.elements.sdk.annotation.ElementPublic;

import java.util.Optional;
import java.util.stream.Stream;

import static dev.getelements.elements.crossfire.model.ProtocolMessage.Category.*;

@ElementPublic
public interface ProtocolMessage {

    /**
     * Returns the type of the message.
     *
     * @return the type
     */
    Type getType();

    /**
     * Indicates if the message is server-only. Server-only signals are generated by the server and not sent by clients.
     * A client attempting to send a server-only signal will receive an error.
     *
     * @return true if the signal is server-only, false otherwise
     */
    default boolean isServerOnly() {
        return false;
    }

    @ElementPublic
    enum Type {

        /**
         * Indicates the request is to find a match. The server will select
         */
        FIND(HANDSHAKE, FindHandshakeRequest.class),

        /**
         * Indicates the request is to join a match. The server will select the specific match.
         */
        JOIN(HANDSHAKE, JoinHandshakeRequest.class),

        /**
         * Indicates that the client has successfully connected to a match.
         */
        MATCHED(HANDSHAKE, MatchedResponse.class),

        /**
         * Represents a signal indicating that a profile disconnected from the session.
         */
        CONNECT(SIGNALING, ConnectBroadcastSignal.class),

        /**
         * Represents a signal indicating that a profile disconnected from the session.
         */
        DISCONNECT(SIGNALING, DisconnectBroadcastSignal.class),

        /**
         * Represents a signal that carries an SDP offer.
         */
        SDP_OFFER(SIGNALING_DIRECT, SdpOfferDirectSignal.class),

        /**
         * Represents a signal that carries an SDP answer.
         */
        SDP_ANSWER(SIGNALING_DIRECT, SdpAnswerDirectSignal.class),

        /**
         * Represents a signal that carries a binary payload to be broadcasted to all profiles in the match.
         */
        BINARY_BROADCAST(SIGNALING, BinaryBroadcastSignal.class),

        /**
         * Represents a signal that carries a binary payload to be relayed to a specific profile in the match.
         */
        BINARY_RELAY(SIGNALING_DIRECT, BinaryRelayDirectSignal.class),

        /**
         * Represents a signal that carries a binary payload to be broadcasted to all profiles in the match.
         */
        STRING_BROADCAST(SIGNALING, StringBroadcastSignal.class),

        /**
         * Represents a signal that carries a binary payload to be relayed to a specific profile in the match.
         */
        STRING_RELAY(SIGNALING_DIRECT, StringRelayDirectSignal.class),

        /**
         * Represents a signal that carries a candidate for the WebRTC connection.
         */
        CANDIDATE(SIGNALING_DIRECT, CandidateDirectSignal.class),

        /**
         * Specifies the designated HOST profile
         */
        HOST(SIGNALING, HostBroadcastSignal.class),

        /**
         * Represents a signal that carries a message to be sent to the host.
         */
        ERROR(Category.ERROR, StandardProtocolError.class);

        private final Category category;

        private final Class<? extends ProtocolMessage> messageType;

        Type(Category category, Class<? extends ProtocolMessage> messageType) {
            this.category = category;
            this.messageType = messageType;
        }

        /**
         * Gets the category of the message type.
         *
         * @return the category
         */
        public Category getCategory() {
            return category;
        }

        /**
         * Gets the message type.
         *
         * @return the message type
         */
        public Class<? extends ProtocolMessage> getMessageType() {
            return messageType;
        }

        /**
         * Finds the {@link Type} from the string representation of the type.
         *
         * @return an {@link Optional} of the type
         */
        public static Optional<Type> findType(final String value) {
            return Stream
                    .of(values())
                    .filter(type -> type.name().equalsIgnoreCase(value))
                    .findFirst();
        }


    }

    /**
     * The category of the protocol message. The life of the websocket connection is divided into categories for each
     * phase of the matchmaking system.
     */
    @ElementPublic
    enum Category {

        /**
         * Used in the handshake process, before a match starts.
         */
        HANDSHAKE,

        /**
         * Used in the signaling process, after a match starts signals in this category will be sent to all profiles in
         * the match via the signaling server.
         */
        SIGNALING,

        /**
         * Used for direct signaling between profiles in a match. After a match starts, profiles can send messages
         * directly to the recipient profile via the signaling server.
         **/
        SIGNALING_DIRECT,

        /**
         * Used for error messages.
         */
        ERROR

    }

}
